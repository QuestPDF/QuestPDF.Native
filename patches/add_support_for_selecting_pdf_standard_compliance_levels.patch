diff --git a/dm/DMSrcSink.cpp b/dm/DMSrcSink.cpp
index 5dce47a478..cef7725d77 100644
--- a/dm/DMSrcSink.cpp
+++ b/dm/DMSrcSink.cpp
@@ -2012,7 +2012,8 @@ Result PDFSink::draw(const Src& src, SkBitmap*, SkWStream* dst, SkString*) const
     metadata.fCreator = "Skia/DM";
     metadata.fProducer = "Skia/PDF HEAD"; // Set producer to avoid SK_MILESTONE churn.
     metadata.fRasterDPI = fRasterDpi;
-    metadata.fPDFA = fPDFA;
+    metadata.fPDFAConformanceLevel = fPDFA ? SkPDF::Metadata::PDFA_Conformance::PDFA_2B 
+                                           : SkPDF::Metadata::PDFA_Conformance::None;
     metadata.jpegDecoder = SkPDF::JPEG::Decode;
     metadata.jpegEncoder = SkPDF::JPEG::Encode;
 #if SK_PDF_TEST_EXECUTOR
diff --git a/include/docs/SkPDFDocument.h b/include/docs/SkPDFDocument.h
index ff48f41168..9cd7662520 100644
--- a/include/docs/SkPDFDocument.h
+++ b/include/docs/SkPDFDocument.h
@@ -141,11 +141,28 @@ struct Metadata {
     */
     SkScalar fRasterDPI = SK_ScalarDefaultRasterDPI;
 
-    /** If true, include XMP metadata, a document UUID, and sRGB output intent
-        information.  This adds length to the document and makes it
-        non-reproducable, but are necessary features for PDF/A-2b conformance
-    */
-    bool fPDFA = false;
+    /** PDF/A conformance level specification. */
+    enum class PDFA_Conformance : int {
+        None = 0,    // No PDF/A compliance
+        PDFA_1A = 1,  // PDF/A-1a
+        PDFA_1B = 2,  // PDF/A-1b
+        PDFA_2A = 3,  // PDF/A-2a
+        PDFA_2B = 4,  // PDF/A-2b
+        PDFA_2U = 5,  // PDF/A-2u
+        PDFA_3A = 6,  // PDF/A-3a
+        PDFA_3B = 7,  // PDF/A-3b
+        PDFA_3U = 8,  // PDF/A-3u
+    } fPDFAConformance = PDFA_Conformance::None;
+
+    /** PDF/UA conformance level specification. */
+    enum class PDFUA_Conformance : int {
+        None = 0,    // No PDF/UA compliance
+        PDFUA_1 = 1,  // PDF/UA-1
+    } fPDFUAConformance = PDFUA_Conformance::None;
+
+    bool requiresXMP() const {
+        return fPDFAConformance != PDFA_Conformance::None || fPDFUAConformance != PDFUA_Conformance::None;
+    }
 
     /** Encoding quality controls the trade-off between size and quality. By
         default this is set to 101 percent, which corresponds to lossless
diff --git a/src/pdf/SkPDFDocument.cpp b/src/pdf/SkPDFDocument.cpp
index ac82078af7..0d0bb52301 100644
--- a/src/pdf/SkPDFDocument.cpp
+++ b/src/pdf/SkPDFDocument.cpp
@@ -279,7 +279,7 @@ SkCanvas* SkPDFDocument::onBeginPage(SkScalar width, SkScalar height) {
         }
 
         fInfoDict = this->emit(*SkPDFMetadata::MakeDocumentInformationDict(fMetadata));
-        if (fMetadata.fPDFA) {
+        if (fMetadata.requiresXMP()) {
             fUUID = SkPDFMetadata::CreateUUID(fMetadata);
             // We use the same UUID for Document ID and Instance ID since this
             // is the first revision of this document (and Skia does not
@@ -617,7 +617,7 @@ void SkPDFDocument::onClose(SkWStream* stream) {
         return;
     }
     auto docCatalog = SkPDFMakeDict("Catalog");
-    if (fMetadata.fPDFA) {
+    if (fMetadata.requiresXMP()) {
         SkASSERT(fXMP != SkPDFIndirectReference());
         docCatalog->insertRef("Metadata", fXMP);
         // Don't specify OutputIntents if we are not in PDF/A mode since
diff --git a/src/pdf/SkPDFMetadata.cpp b/src/pdf/SkPDFMetadata.cpp
index 38438414d8..3211c027d9 100644
--- a/src/pdf/SkPDFMetadata.cpp
+++ b/src/pdf/SkPDFMetadata.cpp
@@ -232,6 +232,101 @@ SkString escape_xml(const SkString& input,
     return output;
 }
 
+void GetPDFAPartAndConformance(const SkPDF::Metadata& metadata, const char** part, const char** conformance) {
+    *part = "3";
+    *conformance = "B";
+
+    if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_1A) {
+        *part = "1";
+        *conformance = "A";
+    }
+    else if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_1B) {
+        *part = "1";
+        *conformance = "B";
+    }
+    else if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_2A) {
+        *part = "2";
+        *conformance = "A";
+    }
+    else if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_2B) {
+        *part = "2";
+        *conformance = "B";
+    }
+    else if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_2U) {
+        *part = "2";
+        *conformance = "U";
+    }
+    else if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_3A) {
+        *part = "3";
+        *conformance = "A";
+    }
+    else if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_3B) {
+        *part = "3";
+        *conformance = "B";
+    }
+    else if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_3U) {
+        *part = "3";
+        *conformance = "U";
+    }
+}
+
+SkString GetPDFAConformanceXML(const SkPDF::Metadata& metadata) {
+    if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::None) {
+        return SkString();
+    }
+
+    const char* part;
+    const char* conformance;
+    GetPDFAPartAndConformance(metadata, &part, &conformance);
+
+    return SkStringPrintf(
+            "<rdf:Description rdf:about=\"\" xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\">\n"
+            "  <pdfaid:part>%s</pdfaid:part>\n"
+            "  <pdfaid:conformance>%s</pdfaid:conformance>\n"
+            "</rdf:Description>\n",
+            part, conformance);
+}
+
+SkString GetPDFUAConformanceXML(const SkPDF::Metadata& metadata) {
+    if (metadata.fPDFUAConformance == SkPDF::Metadata::PDFUA_Conformance::None) {
+        return SkString();
+    }
+
+    const char* part = "1";
+
+    if (metadata.fPDFUAConformance == SkPDF::Metadata::PDFUA_Conformance::PDFUA_1) {
+        part = "1";
+    }
+
+    return SkStringPrintf(
+            "<rdf:Description rdf:about=\"\"\n"
+            " xmlns:pdfaExtension=\"http://www.aiim.org/pdfa/ns/extension/\"\n"
+            " xmlns:pdfaSchema=\"http://www.aiim.org/pdfa/ns/schema#\"\n"
+            " xmlns:pdfaProperty=\"http://www.aiim.org/pdfa/ns/property#\"\n"
+            " xmlns:pdfuaid=\"http://www.aiim.org/pdfua/ns/id/\">\n"
+            " <pdfaExtension:schemas>\n"
+            "  <rdf:Bag>\n"
+            "   <rdf:li rdf:parseType=\"Resource\">\n"
+            "    <pdfaSchema:schema>PDF/UA Universal Accessibility Schema</pdfaSchema:schema>\n"
+            "    <pdfaSchema:namespaceURI>http://www.aiim.org/pdfua/ns/id/</pdfaSchema:namespaceURI>\n"
+            "    <pdfaSchema:prefix>pdfuaid</pdfaSchema:prefix>\n"
+            "    <pdfaSchema:property>\n"
+            "     <rdf:Seq>\n"
+            "      <rdf:li rdf:parseType=\"Resource\">\n"
+            "       <pdfaProperty:name>part</pdfaProperty:name>\n"
+            "       <pdfaProperty:valueType>Integer</pdfaProperty:valueType>\n"
+            "       <pdfaProperty:category>internal</pdfaProperty:category>\n"
+            "       <pdfaProperty:description>Indicates, which part of ISO 14289 standard is followed</pdfaProperty:description>\n"
+            "      </rdf:li>\n"
+            "     </rdf:Seq>\n"
+            "    </pdfaSchema:property>\n"
+            "   </rdf:li>\n"
+            "  </rdf:Bag>\n"
+            "</pdfaExtension:schemas>\n"
+            "<pdfuaid:part>%s</pdfuaid:part>\n"
+        "</rdf:Description>", part);
+}
+
 SkPDFIndirectReference SkPDFMetadata::MakeXMPObject(
         const SkPDF::Metadata& metadata,
         const SkUUID& doc,
@@ -248,10 +343,7 @@ SkPDFIndirectReference SkPDFMetadata::MakeXMPObject(
             " xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\"\n"
             " xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n"
             " xmlns:xmpMM=\"http://ns.adobe.com/xap/1.0/mm/\"\n"
-            " xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\"\n"
-            " xmlns:pdfaid=\"http://www.aiim.org/pdfa/ns/id/\">\n"
-            "<pdfaid:part>2</pdfaid:part>\n"
-            "<pdfaid:conformance>B</pdfaid:conformance>\n"
+            " xmlns:pdf=\"http://ns.adobe.com/pdf/1.3/\">\n"
             "%s"  // ModifyDate
             "%s"  // CreateDate
             "%s"  // xmp:CreatorTool
@@ -265,10 +357,15 @@ SkPDFIndirectReference SkPDFMetadata::MakeXMPObject(
             "%s"  // pdf:Producer
             "%s"  // pdf:Keywords
             "</rdf:Description>\n"
+            "%s"  // PDF/A description
+            "%s"  // PDF/UA description
             "</rdf:RDF>\n"
             "</x:xmpmeta>\n"  // Note:  the standard suggests 4k of padding.
             "<?xpacket end=\"w\"?>\n";
 
+    auto pdfaConformance = GetPDFAConformanceXML(metadata);
+    auto pdfuaConformance = GetPDFUAConformanceXML(metadata);
+
     SkString creationDate;
     SkString modificationDate;
     if (metadata.fCreation != kZeroTime) {
@@ -314,12 +411,14 @@ SkPDFIndirectReference SkPDFMetadata::MakeXMPObject(
     SkString instanceID = uuid_to_string(instance);
     SkASSERT(0 == count_xml_escape_size(instanceID));
 
-
     auto value = SkStringPrintf(
-            templateString, modificationDate.c_str(), creationDate.c_str(),
+            templateString,
+            modificationDate.c_str(), creationDate.c_str(),
             creator.c_str(), title.c_str(), subject.c_str(), author.c_str(),
             keywords1.c_str(), documentID.c_str(), instanceID.c_str(),
-            producer.c_str(), keywords2.c_str());
+            producer.c_str(), keywords2.c_str(),
+            pdfaConformance.c_str(),
+            pdfuaConformance.c_str());
 
     std::unique_ptr<SkPDFDict> dict = SkPDFMakeDict("Metadata");
     dict->insertName("Subtype", "XML");
diff --git a/tests/PDFDocumentTest.cpp b/tests/PDFDocumentTest.cpp
index c722ac064d..b33712e7ef 100644
--- a/tests/PDFDocumentTest.cpp
+++ b/tests/PDFDocumentTest.cpp
@@ -171,7 +171,7 @@ DEF_TEST(SkPDF_pdfa_document, r) {
     SkPDF::Metadata pdfMetadata;
     pdfMetadata.fTitle = "test document";
     pdfMetadata.fCreation = {0, 1999, 12, 5, 31, 23, 59, 59};
-    pdfMetadata.fPDFA = true;
+    pdfMetadata.fPDFAConformance = SkPDF::Metadata::PDFA_Conformance::PDFA_2B;
     pdfMetadata.jpegDecoder = SkPDF::JPEG::Decode;
     pdfMetadata.jpegEncoder = SkPDF::JPEG::Encode;
 
@@ -194,7 +194,7 @@ DEF_TEST(SkPDF_pdfa_document, r) {
         }
     }
     pdfMetadata.fProducer = "phoney library";
-    pdfMetadata.fPDFA = true;
+    pdfMetadata.fPDFAConformance = SkPDF::Metadata::PDFA_Conformance::PDFA_2B;
     doc = SkPDF::MakeDocument(&buffer, pdfMetadata);
     doc->beginPage(64, 64)->drawColor(SK_ColorRED);
     doc->close();
@@ -218,7 +218,7 @@ DEF_TEST(SkPDF_unicode_metadata, r) {
     pdfMetadata.fTitle   = "ùìêùìëùìíùììùìî ùìïùìñùìóùìòùìô"; // Out of basic multilingual plane
     pdfMetadata.fAuthor  = "ABCDE FGHIJ"; // ASCII
     pdfMetadata.fSubject = "Œ±Œ≤Œ≥Œ¥Œµ Œ∂Œ∑Œ∏ŒπŒ∫"; // inside  basic multilingual plane
-    pdfMetadata.fPDFA = true;
+    pdfMetadata.fPDFAConformance = SkPDF::Metadata::PDFA_Conformance::PDFA_2B;
     pdfMetadata.jpegDecoder = SkPDF::JPEG::Decode;
     pdfMetadata.jpegEncoder = SkPDF::JPEG::Encode;
 
diff --git a/tools/using_skia_and_harfbuzz.cpp b/tools/using_skia_and_harfbuzz.cpp
index 6d0d9e8cca..489f8300e8 100644
--- a/tools/using_skia_and_harfbuzz.cpp
+++ b/tools/using_skia_and_harfbuzz.cpp
@@ -238,7 +238,7 @@ static sk_sp<SkDocument> MakePDFDocument(const Config &config, SkWStream *wStrea
         SkPDFUtils::GetDateTime(&now);
         pdf_info.fCreation = now;
         pdf_info.fModified = now;
-        pdf_info.fPDFA = true;
+        pdf_info.fPDFAConformance = SkPDF::Metadata::PDFA_Conformance::PDFA_2B;
     #endif
     pdf_info.jpegDecoder = SkPDF::JPEG::Decode;
     pdf_info.jpegEncoder = SkPDF::JPEG::Encode;
