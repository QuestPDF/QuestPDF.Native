diff --git a/src/pdf/SkPDFFont.cpp b/src/pdf/SkPDFFont.cpp
index 204a3441eb..46940ade0d 100644
--- a/src/pdf/SkPDFFont.cpp
+++ b/src/pdf/SkPDFFont.cpp
@@ -48,40 +48,41 @@
 #include "src/core/SkMask.h"
 #include "src/core/SkMaskFilterBase.h"
 #include "src/core/SkPathEffectBase.h"
 #include "src/core/SkStrike.h"
 #include "src/core/SkStrikeSpec.h"
 #include "src/core/SkTHash.h"
 #include "src/pdf/SkPDFBitmap.h"
 #include "src/pdf/SkPDFDevice.h"
 #include "src/pdf/SkPDFDocumentPriv.h"
 #include "src/pdf/SkPDFFormXObject.h"
 #include "src/pdf/SkPDFGraphicState.h"
 #include "src/pdf/SkPDFMakeCIDGlyphWidthsArray.h"
 #include "src/pdf/SkPDFMakeToUnicodeCmap.h"
 #include "src/pdf/SkPDFSubsetFont.h"
 #include "src/pdf/SkPDFType1Font.h"
 #include "src/pdf/SkPDFUtils.h"
 
 #include <limits.h>
 #include <algorithm>
 #include <cstddef>
+#include <cstring>
 #include <initializer_list>
 #include <memory>
 #include <optional>
 #include <utility>
 
 using namespace skia_private;
 
 void SkPDFFont::GetType1GlyphNames(const SkTypeface& face, SkString* dst) {
     face.getPostScriptGlyphNames(dst);
 }
 
 namespace {
 // PDF's notion of symbolic vs non-symbolic is related to the character set, not
 // symbols vs. characters.  Rarely is a font the right character set to call it
 // non-symbolic, so always call it symbolic.  (PDF 1.4 spec, section 5.7.1)
 static const int32_t kPdfSymbolic = 4;
 
 // scale from em-units to base-1000, returning as a SkScalar
 inline SkScalar from_font_units(SkScalar scaled, uint16_t emSize) {
     return emSize == 1000 ? scaled : scaled * 1000 / emSize;
@@ -421,55 +422,89 @@ void SkPDFFont::PopulateCommonFontDescriptor(SkPDFDict* descriptor,
     descriptor->insertScalar("StemV",
             scaleFromFontUnits(metrics.fStemV, emSize));
     descriptor->insertScalar("CapHeight",
             scaleFromFontUnits(metrics.fCapHeight, emSize));
     descriptor->insertInt("ItalicAngle", metrics.fItalicAngle);
     descriptor->insertObject("FontBBox",
                              SkPDFMakeArray(scaleFromFontUnits(metrics.fBBox.left(), emSize),
                                             scaleFromFontUnits(metrics.fBBox.bottom(), emSize),
                                             scaleFromFontUnits(metrics.fBBox.right(), emSize),
                                             scaleFromFontUnits(metrics.fBBox.top(), emSize)));
     if (defaultWidth > 0) {
         descriptor->insertScalar("MissingWidth",
                 scaleFromFontUnits(defaultWidth, emSize));
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 //  Type0Font
 ///////////////////////////////////////////////////////////////////////////////
 
+// Creates a CIDSet stream for PDF/A compliance.
+// The CIDSet is a bit array identifying which CIDs (Character IDs) are present
+// in the embedded subset font, as required by PDF/A and other ISO standards.
+static sk_sp<SkData> make_cid_set(const SkTypeface& typeface, const SkPDFGlyphUse& glyphUsage) {
+    // Calculate the number of bytes needed (one bit per glyph, rounded up to byte boundary)
+    size_t numGlyphs = typeface.countGlyphs();
+    size_t cidSetSize = (numGlyphs + 7) / 8;  // Round up to nearest byte
+    auto cidSetData = SkData::MakeUninitialized(cidSetSize);
+    uint8_t* cidSetBytes = static_cast<uint8_t*>(cidSetData->writable_data());
+    memset(cidSetBytes, 0, cidSetSize);
+    
+    // Set bits for each glyph that's actually used in the subset
+    glyphUsage.getSetValues([cidSetBytes](size_t gid) {
+        size_t byteIndex = gid / 8;
+        size_t bitIndex = 7 - (gid % 8);  // PDF uses big-endian bit ordering
+        cidSetBytes[byteIndex] |= (1 << bitIndex);
+    });
+    
+    return cidSetData;
+}
+
 static void emit_subset_type0(const SkPDFFont& font, SkPDFDocument* doc) {
     const SkTypeface& typeface = font.strike().fPath.fStrikeSpec.typeface();
     const SkAdvancedTypefaceMetrics* metricsPtr = SkPDFFont::GetMetrics(typeface, doc);
     SkASSERT(metricsPtr);
     if (!metricsPtr) {
         return;
     }
     const SkAdvancedTypefaceMetrics& metrics = *metricsPtr;
     SkASSERT(can_embed(metrics));
     SkAdvancedTypefaceMetrics::FontType type = font.getType();
 
     auto descriptor = SkPDFMakeDict("FontDescriptor");
     uint16_t emSize = SkToU16(SkScalarRoundToInt(font.strike().fPath.fUnitsPerEM));
     SkPDFFont::PopulateCommonFontDescriptor(descriptor.get(), metrics, emSize, 0);
 
+    // Add CIDSet for PDF/A-1a and PDF/A-1b compliance
+    // PDF/A-1 requires CIDSet in subset fonts (ISO 19005-1:2005)
+    const SkPDF::Metadata& metadata = doc->metadata();
+    if (metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_1A ||
+        metadata.fPDFAConformance == SkPDF::Metadata::PDFA_Conformance::PDFA_1B) {
+        sk_sp<SkData> cidSetData = make_cid_set(typeface, font.glyphUsage());
+        descriptor->insertRef("CIDSet",
+                             SkPDFStreamOut(nullptr,
+                                           SkMemoryStream::Make(std::move(cidSetData)),
+                                           doc,
+                                           SkPDFSteamCompressionEnabled::Yes));
+    }
+
     int ttcIndex;
     std::unique_ptr<SkStreamAsset> fontAsset = typeface.openStream(&ttcIndex);
     size_t fontSize = fontAsset ? fontAsset->getLength() : 0;
     if (0 == fontSize) {
         SkDebugf("Error: (SkTypeface)(%p)::openStream() returned "
                  "empty stream (%p) when identified as kType1CID_Font "
                  "or kTrueType_Font.\n", &typeface, fontAsset.get());
     } else if (type == SkAdvancedTypefaceMetrics::kTrueType_Font) {
         sk_sp<SkData> subsetFontData;
         if (can_subset(metrics)) {
             SkASSERT(font.firstGlyphID() == 1);
             subsetFontData = SkPDFSubsetFont(typeface, font.glyphUsage());
         }
         std::unique_ptr<SkStreamAsset> subsetFontAsset;
         if (subsetFontData) {
             subsetFontAsset = SkMemoryStream::Make(std::move(subsetFontData));
         } else {
             // If subsetting fails, fall back to original font data.
             subsetFontAsset = std::move(fontAsset);
         }
