From 6a9ceeb177e47eb0f964f86fb9e25826a1927281 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marcin=20Zi=C4=85bek?= <marcin@ziabek.com>
Date: Wed, 24 Sep 2025 18:14:35 +0200
Subject: [PATCH] improve-support-for-semantic-links

---
 src/pdf/SkPDFDocument.cpp | 32 ++++++++++++++++++++++++++++++--
 1 file changed, 30 insertions(+), 2 deletions(-)

diff --git a/src/pdf/SkPDFDocument.cpp b/src/pdf/SkPDFDocument.cpp
index ac82078af7..62d8742c14 100644
--- a/src/pdf/SkPDFDocument.cpp
+++ b/src/pdf/SkPDFDocument.cpp
@@ -317,59 +317,87 @@ static void populate_link_annotation(SkPDFDict* annotation, const SkRect& r) {
 }
 
 static SkPDFIndirectReference append_destinations(
         SkPDFDocument* doc,
         const std::vector<SkPDFNamedDestination>& namedDestinations)
 {
     SkPDFDict destinations;
     for (const SkPDFNamedDestination& dest : namedDestinations) {
         auto pdfDest = SkPDFMakeArray();
         pdfDest->reserve(5);
         pdfDest->appendRef(dest.fPage);
         pdfDest->appendName("XYZ");
         pdfDest->appendScalar(dest.fPoint.x());
         pdfDest->appendScalar(dest.fPoint.y());
         pdfDest->appendInt(0);  // Leave zoom unchanged
         destinations.insertObject(ToValidUtf8String(*dest.fName), std::move(pdfDest));
     }
     return doc->emit(destinations);
 }
 
+
+void GetLinkAnnotationConfiguration(sk_sp<SkData> data, SkString* destination, SkString* contents) {
+    if (!data || data->size() == 0) {
+        return;
+    }
+
+    auto annotationData = ToValidUtf8String(*data);
+
+    const auto delimiter = "::questpdf_delimiter::";
+    auto delimiterPosition = annotationData.find(delimiter);
+
+    if (delimiterPosition == -1) {
+        *destination = annotationData;
+        return;
+    }
+
+    *destination = SkString(annotationData.c_str(), delimiterPosition);
+    *contents = SkString(annotationData.c_str() + delimiterPosition + strlen(delimiter));
+}
+
 std::unique_ptr<SkPDFArray> SkPDFDocument::getAnnotations() {
     std::unique_ptr<SkPDFArray> array;
     size_t count = fCurrentPageLinks.size();
     if (0 == count) {
         return array;  // is nullptr
     }
     array = SkPDFMakeArray();
     array->reserve(count);
     for (const auto& link : fCurrentPageLinks) {
         SkPDFDict annotation("Annot");
         populate_link_annotation(&annotation, link->fRect);
+
+        SkString destination; 
+        SkString contents; 
+        GetLinkAnnotationConfiguration(link->fData, &destination, &contents);
+
+        if (!contents.isEmpty())
+            annotation.insertByteString("Contents", contents);
+
         if (link->fType == SkPDFLink::Type::kUrl) {
             std::unique_ptr<SkPDFDict> action = SkPDFMakeDict("Action");
             action->insertName("S", "URI");
             // This is documented to be a 7 bit ASCII (byte) string.
-            action->insertByteString("URI", ToValidUtf8String(*link->fData));
+            action->insertByteString("URI", destination);
             annotation.insertObject("A", std::move(action));
         } else if (link->fType == SkPDFLink::Type::kNamedDestination) {
-            annotation.insertName("Dest", ToValidUtf8String(*link->fData));
+            annotation.insertName("Dest", destination);
         } else {
             SkDEBUGFAIL("Unknown link type.");
         }
 
         SkPDFIndirectReference annotationRef = this->reserveRef();
         if (link->fElemId) {
             int structParentKey = this->createStructParentKeyForElemId(link->fElemId, annotationRef);
             if (structParentKey != -1) {
                 annotation.insertInt("StructParent", structParentKey);
             }
         }
 
         this->emit(annotation, annotationRef);
         array->appendRef(annotationRef);
     }
     return array;
 }
 
 void SkPDFDocument::onEndPage() {
     SkASSERT(!fCanvas.imageInfo().dimensions().isZero());
-- 
2.46.1

